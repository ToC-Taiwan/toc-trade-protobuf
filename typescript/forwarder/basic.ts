/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.26.1
 * source: forwarder/basic.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../google/protobuf/empty";
import * as pb_1 from "google-protobuf";
export class BeatMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        message?: string;
        error?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("message" in data && data.message != undefined) {
                this.message = data.message;
            }
            if ("error" in data && data.error != undefined) {
                this.error = data.error;
            }
        }
    }
    get message() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set message(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get error() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set error(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        message?: string;
        error?: string;
    }): BeatMessage {
        const message = new BeatMessage({});
        if (data.message != null) {
            message.message = data.message;
        }
        if (data.error != null) {
            message.error = data.error;
        }
        return message;
    }
    toObject() {
        const data: {
            message?: string;
            error?: string;
        } = {};
        if (this.message != null) {
            data.message = this.message;
        }
        if (this.error != null) {
            data.error = this.error;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.message.length)
            writer.writeString(1, this.message);
        if (this.error.length)
            writer.writeString(2, this.error);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BeatMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BeatMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.message = reader.readString();
                    break;
                case 2:
                    message.error = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BeatMessage {
        return BeatMessage.deserialize(bytes);
    }
}
export class ShioajiUsage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        connections?: number;
        bytes?: number;
        limit_bytes?: number;
        remaining_bytes?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("connections" in data && data.connections != undefined) {
                this.connections = data.connections;
            }
            if ("bytes" in data && data.bytes != undefined) {
                this.bytes = data.bytes;
            }
            if ("limit_bytes" in data && data.limit_bytes != undefined) {
                this.limit_bytes = data.limit_bytes;
            }
            if ("remaining_bytes" in data && data.remaining_bytes != undefined) {
                this.remaining_bytes = data.remaining_bytes;
            }
        }
    }
    get connections() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set connections(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get bytes() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set bytes(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get limit_bytes() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set limit_bytes(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get remaining_bytes() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set remaining_bytes(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        connections?: number;
        bytes?: number;
        limit_bytes?: number;
        remaining_bytes?: number;
    }): ShioajiUsage {
        const message = new ShioajiUsage({});
        if (data.connections != null) {
            message.connections = data.connections;
        }
        if (data.bytes != null) {
            message.bytes = data.bytes;
        }
        if (data.limit_bytes != null) {
            message.limit_bytes = data.limit_bytes;
        }
        if (data.remaining_bytes != null) {
            message.remaining_bytes = data.remaining_bytes;
        }
        return message;
    }
    toObject() {
        const data: {
            connections?: number;
            bytes?: number;
            limit_bytes?: number;
            remaining_bytes?: number;
        } = {};
        if (this.connections != null) {
            data.connections = this.connections;
        }
        if (this.bytes != null) {
            data.bytes = this.bytes;
        }
        if (this.limit_bytes != null) {
            data.limit_bytes = this.limit_bytes;
        }
        if (this.remaining_bytes != null) {
            data.remaining_bytes = this.remaining_bytes;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.connections != 0)
            writer.writeInt64(1, this.connections);
        if (this.bytes != 0)
            writer.writeInt64(2, this.bytes);
        if (this.limit_bytes != 0)
            writer.writeInt64(3, this.limit_bytes);
        if (this.remaining_bytes != 0)
            writer.writeInt64(4, this.remaining_bytes);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShioajiUsage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShioajiUsage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.connections = reader.readInt64();
                    break;
                case 2:
                    message.bytes = reader.readInt64();
                    break;
                case 3:
                    message.limit_bytes = reader.readInt64();
                    break;
                case 4:
                    message.remaining_bytes = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ShioajiUsage {
        return ShioajiUsage.deserialize(bytes);
    }
}
export class StockDetailResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        stock?: StockDetailMessage[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("stock" in data && data.stock != undefined) {
                this.stock = data.stock;
            }
        }
    }
    get stock() {
        return pb_1.Message.getRepeatedWrapperField(this, StockDetailMessage, 1) as StockDetailMessage[];
    }
    set stock(value: StockDetailMessage[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        stock?: ReturnType<typeof StockDetailMessage.prototype.toObject>[];
    }): StockDetailResponse {
        const message = new StockDetailResponse({});
        if (data.stock != null) {
            message.stock = data.stock.map(item => StockDetailMessage.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            stock?: ReturnType<typeof StockDetailMessage.prototype.toObject>[];
        } = {};
        if (this.stock != null) {
            data.stock = this.stock.map((item: StockDetailMessage) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.stock.length)
            writer.writeRepeatedMessage(1, this.stock, (item: StockDetailMessage) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StockDetailResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StockDetailResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.stock, () => pb_1.Message.addToRepeatedWrapperField(message, 1, StockDetailMessage.deserialize(reader), StockDetailMessage));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StockDetailResponse {
        return StockDetailResponse.deserialize(bytes);
    }
}
export class FutureDetailResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        future?: FutureDetailMessage[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("future" in data && data.future != undefined) {
                this.future = data.future;
            }
        }
    }
    get future() {
        return pb_1.Message.getRepeatedWrapperField(this, FutureDetailMessage, 1) as FutureDetailMessage[];
    }
    set future(value: FutureDetailMessage[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        future?: ReturnType<typeof FutureDetailMessage.prototype.toObject>[];
    }): FutureDetailResponse {
        const message = new FutureDetailResponse({});
        if (data.future != null) {
            message.future = data.future.map(item => FutureDetailMessage.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            future?: ReturnType<typeof FutureDetailMessage.prototype.toObject>[];
        } = {};
        if (this.future != null) {
            data.future = this.future.map((item: FutureDetailMessage) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.future.length)
            writer.writeRepeatedMessage(1, this.future, (item: FutureDetailMessage) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FutureDetailResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FutureDetailResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.future, () => pb_1.Message.addToRepeatedWrapperField(message, 1, FutureDetailMessage.deserialize(reader), FutureDetailMessage));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FutureDetailResponse {
        return FutureDetailResponse.deserialize(bytes);
    }
}
export class OptionDetailResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        option?: OptionDetailMessage[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("option" in data && data.option != undefined) {
                this.option = data.option;
            }
        }
    }
    get option() {
        return pb_1.Message.getRepeatedWrapperField(this, OptionDetailMessage, 1) as OptionDetailMessage[];
    }
    set option(value: OptionDetailMessage[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        option?: ReturnType<typeof OptionDetailMessage.prototype.toObject>[];
    }): OptionDetailResponse {
        const message = new OptionDetailResponse({});
        if (data.option != null) {
            message.option = data.option.map(item => OptionDetailMessage.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            option?: ReturnType<typeof OptionDetailMessage.prototype.toObject>[];
        } = {};
        if (this.option != null) {
            data.option = this.option.map((item: OptionDetailMessage) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.option.length)
            writer.writeRepeatedMessage(1, this.option, (item: OptionDetailMessage) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionDetailResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionDetailResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.option, () => pb_1.Message.addToRepeatedWrapperField(message, 1, OptionDetailMessage.deserialize(reader), OptionDetailMessage));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionDetailResponse {
        return OptionDetailResponse.deserialize(bytes);
    }
}
export class StockDetailMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        exchange?: string;
        category?: string;
        code?: string;
        name?: string;
        reference?: number;
        update_date?: string;
        day_trade?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("exchange" in data && data.exchange != undefined) {
                this.exchange = data.exchange;
            }
            if ("category" in data && data.category != undefined) {
                this.category = data.category;
            }
            if ("code" in data && data.code != undefined) {
                this.code = data.code;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("reference" in data && data.reference != undefined) {
                this.reference = data.reference;
            }
            if ("update_date" in data && data.update_date != undefined) {
                this.update_date = data.update_date;
            }
            if ("day_trade" in data && data.day_trade != undefined) {
                this.day_trade = data.day_trade;
            }
        }
    }
    get exchange() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set exchange(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get category() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set category(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get code() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set code(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get reference() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set reference(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get update_date() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set update_date(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get day_trade() {
        return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set day_trade(value: string) {
        pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
        exchange?: string;
        category?: string;
        code?: string;
        name?: string;
        reference?: number;
        update_date?: string;
        day_trade?: string;
    }): StockDetailMessage {
        const message = new StockDetailMessage({});
        if (data.exchange != null) {
            message.exchange = data.exchange;
        }
        if (data.category != null) {
            message.category = data.category;
        }
        if (data.code != null) {
            message.code = data.code;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.reference != null) {
            message.reference = data.reference;
        }
        if (data.update_date != null) {
            message.update_date = data.update_date;
        }
        if (data.day_trade != null) {
            message.day_trade = data.day_trade;
        }
        return message;
    }
    toObject() {
        const data: {
            exchange?: string;
            category?: string;
            code?: string;
            name?: string;
            reference?: number;
            update_date?: string;
            day_trade?: string;
        } = {};
        if (this.exchange != null) {
            data.exchange = this.exchange;
        }
        if (this.category != null) {
            data.category = this.category;
        }
        if (this.code != null) {
            data.code = this.code;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.reference != null) {
            data.reference = this.reference;
        }
        if (this.update_date != null) {
            data.update_date = this.update_date;
        }
        if (this.day_trade != null) {
            data.day_trade = this.day_trade;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.exchange.length)
            writer.writeString(1, this.exchange);
        if (this.category.length)
            writer.writeString(2, this.category);
        if (this.code.length)
            writer.writeString(3, this.code);
        if (this.name.length)
            writer.writeString(4, this.name);
        if (this.reference != 0)
            writer.writeDouble(5, this.reference);
        if (this.update_date.length)
            writer.writeString(6, this.update_date);
        if (this.day_trade.length)
            writer.writeString(7, this.day_trade);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StockDetailMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StockDetailMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.exchange = reader.readString();
                    break;
                case 2:
                    message.category = reader.readString();
                    break;
                case 3:
                    message.code = reader.readString();
                    break;
                case 4:
                    message.name = reader.readString();
                    break;
                case 5:
                    message.reference = reader.readDouble();
                    break;
                case 6:
                    message.update_date = reader.readString();
                    break;
                case 7:
                    message.day_trade = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StockDetailMessage {
        return StockDetailMessage.deserialize(bytes);
    }
}
export class FutureDetailMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        code?: string;
        symbol?: string;
        name?: string;
        category?: string;
        delivery_month?: string;
        delivery_date?: string;
        underlying_kind?: string;
        unit?: number;
        limit_up?: number;
        limit_down?: number;
        reference?: number;
        update_date?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("code" in data && data.code != undefined) {
                this.code = data.code;
            }
            if ("symbol" in data && data.symbol != undefined) {
                this.symbol = data.symbol;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("category" in data && data.category != undefined) {
                this.category = data.category;
            }
            if ("delivery_month" in data && data.delivery_month != undefined) {
                this.delivery_month = data.delivery_month;
            }
            if ("delivery_date" in data && data.delivery_date != undefined) {
                this.delivery_date = data.delivery_date;
            }
            if ("underlying_kind" in data && data.underlying_kind != undefined) {
                this.underlying_kind = data.underlying_kind;
            }
            if ("unit" in data && data.unit != undefined) {
                this.unit = data.unit;
            }
            if ("limit_up" in data && data.limit_up != undefined) {
                this.limit_up = data.limit_up;
            }
            if ("limit_down" in data && data.limit_down != undefined) {
                this.limit_down = data.limit_down;
            }
            if ("reference" in data && data.reference != undefined) {
                this.reference = data.reference;
            }
            if ("update_date" in data && data.update_date != undefined) {
                this.update_date = data.update_date;
            }
        }
    }
    get code() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set code(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get symbol() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set symbol(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get category() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set category(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get delivery_month() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set delivery_month(value: string) {
        pb_1.Message.setField(this, 5, value);
    }
    get delivery_date() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set delivery_date(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get underlying_kind() {
        return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set underlying_kind(value: string) {
        pb_1.Message.setField(this, 7, value);
    }
    get unit() {
        return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
    }
    set unit(value: number) {
        pb_1.Message.setField(this, 8, value);
    }
    get limit_up() {
        return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
    }
    set limit_up(value: number) {
        pb_1.Message.setField(this, 9, value);
    }
    get limit_down() {
        return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
    }
    set limit_down(value: number) {
        pb_1.Message.setField(this, 10, value);
    }
    get reference() {
        return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
    }
    set reference(value: number) {
        pb_1.Message.setField(this, 11, value);
    }
    get update_date() {
        return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
    }
    set update_date(value: string) {
        pb_1.Message.setField(this, 12, value);
    }
    static fromObject(data: {
        code?: string;
        symbol?: string;
        name?: string;
        category?: string;
        delivery_month?: string;
        delivery_date?: string;
        underlying_kind?: string;
        unit?: number;
        limit_up?: number;
        limit_down?: number;
        reference?: number;
        update_date?: string;
    }): FutureDetailMessage {
        const message = new FutureDetailMessage({});
        if (data.code != null) {
            message.code = data.code;
        }
        if (data.symbol != null) {
            message.symbol = data.symbol;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.category != null) {
            message.category = data.category;
        }
        if (data.delivery_month != null) {
            message.delivery_month = data.delivery_month;
        }
        if (data.delivery_date != null) {
            message.delivery_date = data.delivery_date;
        }
        if (data.underlying_kind != null) {
            message.underlying_kind = data.underlying_kind;
        }
        if (data.unit != null) {
            message.unit = data.unit;
        }
        if (data.limit_up != null) {
            message.limit_up = data.limit_up;
        }
        if (data.limit_down != null) {
            message.limit_down = data.limit_down;
        }
        if (data.reference != null) {
            message.reference = data.reference;
        }
        if (data.update_date != null) {
            message.update_date = data.update_date;
        }
        return message;
    }
    toObject() {
        const data: {
            code?: string;
            symbol?: string;
            name?: string;
            category?: string;
            delivery_month?: string;
            delivery_date?: string;
            underlying_kind?: string;
            unit?: number;
            limit_up?: number;
            limit_down?: number;
            reference?: number;
            update_date?: string;
        } = {};
        if (this.code != null) {
            data.code = this.code;
        }
        if (this.symbol != null) {
            data.symbol = this.symbol;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.category != null) {
            data.category = this.category;
        }
        if (this.delivery_month != null) {
            data.delivery_month = this.delivery_month;
        }
        if (this.delivery_date != null) {
            data.delivery_date = this.delivery_date;
        }
        if (this.underlying_kind != null) {
            data.underlying_kind = this.underlying_kind;
        }
        if (this.unit != null) {
            data.unit = this.unit;
        }
        if (this.limit_up != null) {
            data.limit_up = this.limit_up;
        }
        if (this.limit_down != null) {
            data.limit_down = this.limit_down;
        }
        if (this.reference != null) {
            data.reference = this.reference;
        }
        if (this.update_date != null) {
            data.update_date = this.update_date;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.code.length)
            writer.writeString(1, this.code);
        if (this.symbol.length)
            writer.writeString(2, this.symbol);
        if (this.name.length)
            writer.writeString(3, this.name);
        if (this.category.length)
            writer.writeString(4, this.category);
        if (this.delivery_month.length)
            writer.writeString(5, this.delivery_month);
        if (this.delivery_date.length)
            writer.writeString(6, this.delivery_date);
        if (this.underlying_kind.length)
            writer.writeString(7, this.underlying_kind);
        if (this.unit != 0)
            writer.writeInt64(8, this.unit);
        if (this.limit_up != 0)
            writer.writeDouble(9, this.limit_up);
        if (this.limit_down != 0)
            writer.writeDouble(10, this.limit_down);
        if (this.reference != 0)
            writer.writeDouble(11, this.reference);
        if (this.update_date.length)
            writer.writeString(12, this.update_date);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FutureDetailMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FutureDetailMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.code = reader.readString();
                    break;
                case 2:
                    message.symbol = reader.readString();
                    break;
                case 3:
                    message.name = reader.readString();
                    break;
                case 4:
                    message.category = reader.readString();
                    break;
                case 5:
                    message.delivery_month = reader.readString();
                    break;
                case 6:
                    message.delivery_date = reader.readString();
                    break;
                case 7:
                    message.underlying_kind = reader.readString();
                    break;
                case 8:
                    message.unit = reader.readInt64();
                    break;
                case 9:
                    message.limit_up = reader.readDouble();
                    break;
                case 10:
                    message.limit_down = reader.readDouble();
                    break;
                case 11:
                    message.reference = reader.readDouble();
                    break;
                case 12:
                    message.update_date = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FutureDetailMessage {
        return FutureDetailMessage.deserialize(bytes);
    }
}
export class OptionDetailMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        code?: string;
        symbol?: string;
        name?: string;
        category?: string;
        delivery_month?: string;
        delivery_date?: string;
        strike_price?: number;
        option_right?: string;
        underlying_kind?: string;
        unit?: number;
        limit_up?: number;
        limit_down?: number;
        reference?: number;
        update_date?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("code" in data && data.code != undefined) {
                this.code = data.code;
            }
            if ("symbol" in data && data.symbol != undefined) {
                this.symbol = data.symbol;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("category" in data && data.category != undefined) {
                this.category = data.category;
            }
            if ("delivery_month" in data && data.delivery_month != undefined) {
                this.delivery_month = data.delivery_month;
            }
            if ("delivery_date" in data && data.delivery_date != undefined) {
                this.delivery_date = data.delivery_date;
            }
            if ("strike_price" in data && data.strike_price != undefined) {
                this.strike_price = data.strike_price;
            }
            if ("option_right" in data && data.option_right != undefined) {
                this.option_right = data.option_right;
            }
            if ("underlying_kind" in data && data.underlying_kind != undefined) {
                this.underlying_kind = data.underlying_kind;
            }
            if ("unit" in data && data.unit != undefined) {
                this.unit = data.unit;
            }
            if ("limit_up" in data && data.limit_up != undefined) {
                this.limit_up = data.limit_up;
            }
            if ("limit_down" in data && data.limit_down != undefined) {
                this.limit_down = data.limit_down;
            }
            if ("reference" in data && data.reference != undefined) {
                this.reference = data.reference;
            }
            if ("update_date" in data && data.update_date != undefined) {
                this.update_date = data.update_date;
            }
        }
    }
    get code() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set code(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get symbol() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set symbol(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get category() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set category(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get delivery_month() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set delivery_month(value: string) {
        pb_1.Message.setField(this, 5, value);
    }
    get delivery_date() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set delivery_date(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get strike_price() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set strike_price(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    get option_right() {
        return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
    }
    set option_right(value: string) {
        pb_1.Message.setField(this, 8, value);
    }
    get underlying_kind() {
        return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
    }
    set underlying_kind(value: string) {
        pb_1.Message.setField(this, 9, value);
    }
    get unit() {
        return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
    }
    set unit(value: number) {
        pb_1.Message.setField(this, 10, value);
    }
    get limit_up() {
        return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
    }
    set limit_up(value: number) {
        pb_1.Message.setField(this, 11, value);
    }
    get limit_down() {
        return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
    }
    set limit_down(value: number) {
        pb_1.Message.setField(this, 12, value);
    }
    get reference() {
        return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
    }
    set reference(value: number) {
        pb_1.Message.setField(this, 13, value);
    }
    get update_date() {
        return pb_1.Message.getFieldWithDefault(this, 14, "") as string;
    }
    set update_date(value: string) {
        pb_1.Message.setField(this, 14, value);
    }
    static fromObject(data: {
        code?: string;
        symbol?: string;
        name?: string;
        category?: string;
        delivery_month?: string;
        delivery_date?: string;
        strike_price?: number;
        option_right?: string;
        underlying_kind?: string;
        unit?: number;
        limit_up?: number;
        limit_down?: number;
        reference?: number;
        update_date?: string;
    }): OptionDetailMessage {
        const message = new OptionDetailMessage({});
        if (data.code != null) {
            message.code = data.code;
        }
        if (data.symbol != null) {
            message.symbol = data.symbol;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.category != null) {
            message.category = data.category;
        }
        if (data.delivery_month != null) {
            message.delivery_month = data.delivery_month;
        }
        if (data.delivery_date != null) {
            message.delivery_date = data.delivery_date;
        }
        if (data.strike_price != null) {
            message.strike_price = data.strike_price;
        }
        if (data.option_right != null) {
            message.option_right = data.option_right;
        }
        if (data.underlying_kind != null) {
            message.underlying_kind = data.underlying_kind;
        }
        if (data.unit != null) {
            message.unit = data.unit;
        }
        if (data.limit_up != null) {
            message.limit_up = data.limit_up;
        }
        if (data.limit_down != null) {
            message.limit_down = data.limit_down;
        }
        if (data.reference != null) {
            message.reference = data.reference;
        }
        if (data.update_date != null) {
            message.update_date = data.update_date;
        }
        return message;
    }
    toObject() {
        const data: {
            code?: string;
            symbol?: string;
            name?: string;
            category?: string;
            delivery_month?: string;
            delivery_date?: string;
            strike_price?: number;
            option_right?: string;
            underlying_kind?: string;
            unit?: number;
            limit_up?: number;
            limit_down?: number;
            reference?: number;
            update_date?: string;
        } = {};
        if (this.code != null) {
            data.code = this.code;
        }
        if (this.symbol != null) {
            data.symbol = this.symbol;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.category != null) {
            data.category = this.category;
        }
        if (this.delivery_month != null) {
            data.delivery_month = this.delivery_month;
        }
        if (this.delivery_date != null) {
            data.delivery_date = this.delivery_date;
        }
        if (this.strike_price != null) {
            data.strike_price = this.strike_price;
        }
        if (this.option_right != null) {
            data.option_right = this.option_right;
        }
        if (this.underlying_kind != null) {
            data.underlying_kind = this.underlying_kind;
        }
        if (this.unit != null) {
            data.unit = this.unit;
        }
        if (this.limit_up != null) {
            data.limit_up = this.limit_up;
        }
        if (this.limit_down != null) {
            data.limit_down = this.limit_down;
        }
        if (this.reference != null) {
            data.reference = this.reference;
        }
        if (this.update_date != null) {
            data.update_date = this.update_date;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.code.length)
            writer.writeString(1, this.code);
        if (this.symbol.length)
            writer.writeString(2, this.symbol);
        if (this.name.length)
            writer.writeString(3, this.name);
        if (this.category.length)
            writer.writeString(4, this.category);
        if (this.delivery_month.length)
            writer.writeString(5, this.delivery_month);
        if (this.delivery_date.length)
            writer.writeString(6, this.delivery_date);
        if (this.strike_price != 0)
            writer.writeDouble(7, this.strike_price);
        if (this.option_right.length)
            writer.writeString(8, this.option_right);
        if (this.underlying_kind.length)
            writer.writeString(9, this.underlying_kind);
        if (this.unit != 0)
            writer.writeInt64(10, this.unit);
        if (this.limit_up != 0)
            writer.writeDouble(11, this.limit_up);
        if (this.limit_down != 0)
            writer.writeDouble(12, this.limit_down);
        if (this.reference != 0)
            writer.writeDouble(13, this.reference);
        if (this.update_date.length)
            writer.writeString(14, this.update_date);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionDetailMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionDetailMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.code = reader.readString();
                    break;
                case 2:
                    message.symbol = reader.readString();
                    break;
                case 3:
                    message.name = reader.readString();
                    break;
                case 4:
                    message.category = reader.readString();
                    break;
                case 5:
                    message.delivery_month = reader.readString();
                    break;
                case 6:
                    message.delivery_date = reader.readString();
                    break;
                case 7:
                    message.strike_price = reader.readDouble();
                    break;
                case 8:
                    message.option_right = reader.readString();
                    break;
                case 9:
                    message.underlying_kind = reader.readString();
                    break;
                case 10:
                    message.unit = reader.readInt64();
                    break;
                case 11:
                    message.limit_up = reader.readDouble();
                    break;
                case 12:
                    message.limit_down = reader.readDouble();
                    break;
                case 13:
                    message.reference = reader.readDouble();
                    break;
                case 14:
                    message.update_date = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionDetailMessage {
        return OptionDetailMessage.deserialize(bytes);
    }
}
