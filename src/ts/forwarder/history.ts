/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.26.1
 * source: forwarder/history.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class StockNumArrWithDate extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        stock_num_arr?: string[];
        date?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("stock_num_arr" in data && data.stock_num_arr != undefined) {
                this.stock_num_arr = data.stock_num_arr;
            }
            if ("date" in data && data.date != undefined) {
                this.date = data.date;
            }
        }
    }
    get stock_num_arr() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set stock_num_arr(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get date() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set date(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        stock_num_arr?: string[];
        date?: string;
    }): StockNumArrWithDate {
        const message = new StockNumArrWithDate({});
        if (data.stock_num_arr != null) {
            message.stock_num_arr = data.stock_num_arr;
        }
        if (data.date != null) {
            message.date = data.date;
        }
        return message;
    }
    toObject() {
        const data: {
            stock_num_arr?: string[];
            date?: string;
        } = {};
        if (this.stock_num_arr != null) {
            data.stock_num_arr = this.stock_num_arr;
        }
        if (this.date != null) {
            data.date = this.date;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.stock_num_arr.length)
            writer.writeRepeatedString(1, this.stock_num_arr);
        if (this.date.length)
            writer.writeString(2, this.date);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StockNumArrWithDate {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StockNumArrWithDate();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                case 2:
                    message.date = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StockNumArrWithDate {
        return StockNumArrWithDate.deserialize(bytes);
    }
}
export class FutureCodeArrWithDate extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        future_code_arr?: string[];
        date?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("future_code_arr" in data && data.future_code_arr != undefined) {
                this.future_code_arr = data.future_code_arr;
            }
            if ("date" in data && data.date != undefined) {
                this.date = data.date;
            }
        }
    }
    get future_code_arr() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set future_code_arr(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get date() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set date(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        future_code_arr?: string[];
        date?: string;
    }): FutureCodeArrWithDate {
        const message = new FutureCodeArrWithDate({});
        if (data.future_code_arr != null) {
            message.future_code_arr = data.future_code_arr;
        }
        if (data.date != null) {
            message.date = data.date;
        }
        return message;
    }
    toObject() {
        const data: {
            future_code_arr?: string[];
            date?: string;
        } = {};
        if (this.future_code_arr != null) {
            data.future_code_arr = this.future_code_arr;
        }
        if (this.date != null) {
            data.date = this.date;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.future_code_arr.length)
            writer.writeRepeatedString(1, this.future_code_arr);
        if (this.date.length)
            writer.writeString(2, this.date);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FutureCodeArrWithDate {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FutureCodeArrWithDate();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                case 2:
                    message.date = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FutureCodeArrWithDate {
        return FutureCodeArrWithDate.deserialize(bytes);
    }
}
export class StockNumArrWithDateArr extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        stock_num_arr?: string[];
        date_arr?: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("stock_num_arr" in data && data.stock_num_arr != undefined) {
                this.stock_num_arr = data.stock_num_arr;
            }
            if ("date_arr" in data && data.date_arr != undefined) {
                this.date_arr = data.date_arr;
            }
        }
    }
    get stock_num_arr() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set stock_num_arr(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get date_arr() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set date_arr(value: string[]) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        stock_num_arr?: string[];
        date_arr?: string[];
    }): StockNumArrWithDateArr {
        const message = new StockNumArrWithDateArr({});
        if (data.stock_num_arr != null) {
            message.stock_num_arr = data.stock_num_arr;
        }
        if (data.date_arr != null) {
            message.date_arr = data.date_arr;
        }
        return message;
    }
    toObject() {
        const data: {
            stock_num_arr?: string[];
            date_arr?: string[];
        } = {};
        if (this.stock_num_arr != null) {
            data.stock_num_arr = this.stock_num_arr;
        }
        if (this.date_arr != null) {
            data.date_arr = this.date_arr;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.stock_num_arr.length)
            writer.writeRepeatedString(1, this.stock_num_arr);
        if (this.date_arr.length)
            writer.writeRepeatedString(2, this.date_arr);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StockNumArrWithDateArr {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StockNumArrWithDateArr();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                case 2:
                    pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StockNumArrWithDateArr {
        return StockNumArrWithDateArr.deserialize(bytes);
    }
}
export class HistoryTickResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        data?: HistoryTickMessage[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("data" in data && data.data != undefined) {
                this.data = data.data;
            }
        }
    }
    get data() {
        return pb_1.Message.getRepeatedWrapperField(this, HistoryTickMessage, 1) as HistoryTickMessage[];
    }
    set data(value: HistoryTickMessage[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        data?: ReturnType<typeof HistoryTickMessage.prototype.toObject>[];
    }): HistoryTickResponse {
        const message = new HistoryTickResponse({});
        if (data.data != null) {
            message.data = data.data.map(item => HistoryTickMessage.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            data?: ReturnType<typeof HistoryTickMessage.prototype.toObject>[];
        } = {};
        if (this.data != null) {
            data.data = this.data.map((item: HistoryTickMessage) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.data.length)
            writer.writeRepeatedMessage(1, this.data, (item: HistoryTickMessage) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryTickResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryTickResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.data, () => pb_1.Message.addToRepeatedWrapperField(message, 1, HistoryTickMessage.deserialize(reader), HistoryTickMessage));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HistoryTickResponse {
        return HistoryTickResponse.deserialize(bytes);
    }
}
export class HistoryKbarResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        data?: HistoryKbarMessage[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("data" in data && data.data != undefined) {
                this.data = data.data;
            }
        }
    }
    get data() {
        return pb_1.Message.getRepeatedWrapperField(this, HistoryKbarMessage, 1) as HistoryKbarMessage[];
    }
    set data(value: HistoryKbarMessage[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        data?: ReturnType<typeof HistoryKbarMessage.prototype.toObject>[];
    }): HistoryKbarResponse {
        const message = new HistoryKbarResponse({});
        if (data.data != null) {
            message.data = data.data.map(item => HistoryKbarMessage.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            data?: ReturnType<typeof HistoryKbarMessage.prototype.toObject>[];
        } = {};
        if (this.data != null) {
            data.data = this.data.map((item: HistoryKbarMessage) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.data.length)
            writer.writeRepeatedMessage(1, this.data, (item: HistoryKbarMessage) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryKbarResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryKbarResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.data, () => pb_1.Message.addToRepeatedWrapperField(message, 1, HistoryKbarMessage.deserialize(reader), HistoryKbarMessage));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HistoryKbarResponse {
        return HistoryKbarResponse.deserialize(bytes);
    }
}
export class HistoryCloseResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        data?: HistoryCloseMessage[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("data" in data && data.data != undefined) {
                this.data = data.data;
            }
        }
    }
    get data() {
        return pb_1.Message.getRepeatedWrapperField(this, HistoryCloseMessage, 1) as HistoryCloseMessage[];
    }
    set data(value: HistoryCloseMessage[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        data?: ReturnType<typeof HistoryCloseMessage.prototype.toObject>[];
    }): HistoryCloseResponse {
        const message = new HistoryCloseResponse({});
        if (data.data != null) {
            message.data = data.data.map(item => HistoryCloseMessage.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            data?: ReturnType<typeof HistoryCloseMessage.prototype.toObject>[];
        } = {};
        if (this.data != null) {
            data.data = this.data.map((item: HistoryCloseMessage) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.data.length)
            writer.writeRepeatedMessage(1, this.data, (item: HistoryCloseMessage) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryCloseResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryCloseResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.data, () => pb_1.Message.addToRepeatedWrapperField(message, 1, HistoryCloseMessage.deserialize(reader), HistoryCloseMessage));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HistoryCloseResponse {
        return HistoryCloseResponse.deserialize(bytes);
    }
}
export class HistoryTickMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ts?: number;
        close?: number;
        volume?: number;
        bid_price?: number;
        bid_volume?: number;
        ask_price?: number;
        ask_volume?: number;
        tick_type?: number;
        code?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ts" in data && data.ts != undefined) {
                this.ts = data.ts;
            }
            if ("close" in data && data.close != undefined) {
                this.close = data.close;
            }
            if ("volume" in data && data.volume != undefined) {
                this.volume = data.volume;
            }
            if ("bid_price" in data && data.bid_price != undefined) {
                this.bid_price = data.bid_price;
            }
            if ("bid_volume" in data && data.bid_volume != undefined) {
                this.bid_volume = data.bid_volume;
            }
            if ("ask_price" in data && data.ask_price != undefined) {
                this.ask_price = data.ask_price;
            }
            if ("ask_volume" in data && data.ask_volume != undefined) {
                this.ask_volume = data.ask_volume;
            }
            if ("tick_type" in data && data.tick_type != undefined) {
                this.tick_type = data.tick_type;
            }
            if ("code" in data && data.code != undefined) {
                this.code = data.code;
            }
        }
    }
    get ts() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set ts(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get close() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set close(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get volume() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set volume(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get bid_price() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set bid_price(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get bid_volume() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set bid_volume(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get ask_price() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set ask_price(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    get ask_volume() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set ask_volume(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    get tick_type() {
        return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
    }
    set tick_type(value: number) {
        pb_1.Message.setField(this, 8, value);
    }
    get code() {
        return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
    }
    set code(value: string) {
        pb_1.Message.setField(this, 9, value);
    }
    static fromObject(data: {
        ts?: number;
        close?: number;
        volume?: number;
        bid_price?: number;
        bid_volume?: number;
        ask_price?: number;
        ask_volume?: number;
        tick_type?: number;
        code?: string;
    }): HistoryTickMessage {
        const message = new HistoryTickMessage({});
        if (data.ts != null) {
            message.ts = data.ts;
        }
        if (data.close != null) {
            message.close = data.close;
        }
        if (data.volume != null) {
            message.volume = data.volume;
        }
        if (data.bid_price != null) {
            message.bid_price = data.bid_price;
        }
        if (data.bid_volume != null) {
            message.bid_volume = data.bid_volume;
        }
        if (data.ask_price != null) {
            message.ask_price = data.ask_price;
        }
        if (data.ask_volume != null) {
            message.ask_volume = data.ask_volume;
        }
        if (data.tick_type != null) {
            message.tick_type = data.tick_type;
        }
        if (data.code != null) {
            message.code = data.code;
        }
        return message;
    }
    toObject() {
        const data: {
            ts?: number;
            close?: number;
            volume?: number;
            bid_price?: number;
            bid_volume?: number;
            ask_price?: number;
            ask_volume?: number;
            tick_type?: number;
            code?: string;
        } = {};
        if (this.ts != null) {
            data.ts = this.ts;
        }
        if (this.close != null) {
            data.close = this.close;
        }
        if (this.volume != null) {
            data.volume = this.volume;
        }
        if (this.bid_price != null) {
            data.bid_price = this.bid_price;
        }
        if (this.bid_volume != null) {
            data.bid_volume = this.bid_volume;
        }
        if (this.ask_price != null) {
            data.ask_price = this.ask_price;
        }
        if (this.ask_volume != null) {
            data.ask_volume = this.ask_volume;
        }
        if (this.tick_type != null) {
            data.tick_type = this.tick_type;
        }
        if (this.code != null) {
            data.code = this.code;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ts != 0)
            writer.writeInt64(1, this.ts);
        if (this.close != 0)
            writer.writeDouble(2, this.close);
        if (this.volume != 0)
            writer.writeInt64(3, this.volume);
        if (this.bid_price != 0)
            writer.writeDouble(4, this.bid_price);
        if (this.bid_volume != 0)
            writer.writeInt64(5, this.bid_volume);
        if (this.ask_price != 0)
            writer.writeDouble(6, this.ask_price);
        if (this.ask_volume != 0)
            writer.writeInt64(7, this.ask_volume);
        if (this.tick_type != 0)
            writer.writeInt64(8, this.tick_type);
        if (this.code.length)
            writer.writeString(9, this.code);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryTickMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryTickMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ts = reader.readInt64();
                    break;
                case 2:
                    message.close = reader.readDouble();
                    break;
                case 3:
                    message.volume = reader.readInt64();
                    break;
                case 4:
                    message.bid_price = reader.readDouble();
                    break;
                case 5:
                    message.bid_volume = reader.readInt64();
                    break;
                case 6:
                    message.ask_price = reader.readDouble();
                    break;
                case 7:
                    message.ask_volume = reader.readInt64();
                    break;
                case 8:
                    message.tick_type = reader.readInt64();
                    break;
                case 9:
                    message.code = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HistoryTickMessage {
        return HistoryTickMessage.deserialize(bytes);
    }
}
export class HistoryKbarMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        ts?: number;
        close?: number;
        open?: number;
        high?: number;
        low?: number;
        volume?: number;
        code?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ts" in data && data.ts != undefined) {
                this.ts = data.ts;
            }
            if ("close" in data && data.close != undefined) {
                this.close = data.close;
            }
            if ("open" in data && data.open != undefined) {
                this.open = data.open;
            }
            if ("high" in data && data.high != undefined) {
                this.high = data.high;
            }
            if ("low" in data && data.low != undefined) {
                this.low = data.low;
            }
            if ("volume" in data && data.volume != undefined) {
                this.volume = data.volume;
            }
            if ("code" in data && data.code != undefined) {
                this.code = data.code;
            }
        }
    }
    get ts() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set ts(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get close() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set close(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get open() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set open(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get high() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set high(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get low() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set low(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get volume() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set volume(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    get code() {
        return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
    }
    set code(value: string) {
        pb_1.Message.setField(this, 7, value);
    }
    static fromObject(data: {
        ts?: number;
        close?: number;
        open?: number;
        high?: number;
        low?: number;
        volume?: number;
        code?: string;
    }): HistoryKbarMessage {
        const message = new HistoryKbarMessage({});
        if (data.ts != null) {
            message.ts = data.ts;
        }
        if (data.close != null) {
            message.close = data.close;
        }
        if (data.open != null) {
            message.open = data.open;
        }
        if (data.high != null) {
            message.high = data.high;
        }
        if (data.low != null) {
            message.low = data.low;
        }
        if (data.volume != null) {
            message.volume = data.volume;
        }
        if (data.code != null) {
            message.code = data.code;
        }
        return message;
    }
    toObject() {
        const data: {
            ts?: number;
            close?: number;
            open?: number;
            high?: number;
            low?: number;
            volume?: number;
            code?: string;
        } = {};
        if (this.ts != null) {
            data.ts = this.ts;
        }
        if (this.close != null) {
            data.close = this.close;
        }
        if (this.open != null) {
            data.open = this.open;
        }
        if (this.high != null) {
            data.high = this.high;
        }
        if (this.low != null) {
            data.low = this.low;
        }
        if (this.volume != null) {
            data.volume = this.volume;
        }
        if (this.code != null) {
            data.code = this.code;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.ts != 0)
            writer.writeInt64(1, this.ts);
        if (this.close != 0)
            writer.writeDouble(2, this.close);
        if (this.open != 0)
            writer.writeDouble(3, this.open);
        if (this.high != 0)
            writer.writeDouble(4, this.high);
        if (this.low != 0)
            writer.writeDouble(5, this.low);
        if (this.volume != 0)
            writer.writeInt64(6, this.volume);
        if (this.code.length)
            writer.writeString(7, this.code);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryKbarMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryKbarMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ts = reader.readInt64();
                    break;
                case 2:
                    message.close = reader.readDouble();
                    break;
                case 3:
                    message.open = reader.readDouble();
                    break;
                case 4:
                    message.high = reader.readDouble();
                    break;
                case 5:
                    message.low = reader.readDouble();
                    break;
                case 6:
                    message.volume = reader.readInt64();
                    break;
                case 7:
                    message.code = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HistoryKbarMessage {
        return HistoryKbarMessage.deserialize(bytes);
    }
}
export class HistoryCloseMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        date?: string;
        code?: string;
        close?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("date" in data && data.date != undefined) {
                this.date = data.date;
            }
            if ("code" in data && data.code != undefined) {
                this.code = data.code;
            }
            if ("close" in data && data.close != undefined) {
                this.close = data.close;
            }
        }
    }
    get date() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set date(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get code() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set code(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get close() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set close(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        date?: string;
        code?: string;
        close?: number;
    }): HistoryCloseMessage {
        const message = new HistoryCloseMessage({});
        if (data.date != null) {
            message.date = data.date;
        }
        if (data.code != null) {
            message.code = data.code;
        }
        if (data.close != null) {
            message.close = data.close;
        }
        return message;
    }
    toObject() {
        const data: {
            date?: string;
            code?: string;
            close?: number;
        } = {};
        if (this.date != null) {
            data.date = this.date;
        }
        if (this.code != null) {
            data.code = this.code;
        }
        if (this.close != null) {
            data.close = this.close;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.date.length)
            writer.writeString(1, this.date);
        if (this.code.length)
            writer.writeString(2, this.code);
        if (this.close != 0)
            writer.writeDouble(3, this.close);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HistoryCloseMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HistoryCloseMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.date = reader.readString();
                    break;
                case 2:
                    message.code = reader.readString();
                    break;
                case 3:
                    message.close = reader.readDouble();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HistoryCloseMessage {
        return HistoryCloseMessage.deserialize(bytes);
    }
}
export class Date extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        date?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("date" in data && data.date != undefined) {
                this.date = data.date;
            }
        }
    }
    get date() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set date(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        date?: string;
    }): Date {
        const message = new Date({});
        if (data.date != null) {
            message.date = data.date;
        }
        return message;
    }
    toObject() {
        const data: {
            date?: string;
        } = {};
        if (this.date != null) {
            data.date = this.date;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.date.length)
            writer.writeString(1, this.date);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Date {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Date();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.date = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Date {
        return Date.deserialize(bytes);
    }
}
